--- src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
+++ src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
@@ -29,9 +29,8 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @param elemento el elemento del vértice.
          */
         protected Vertice(T elemento) {
-             // Aquí va su código.
-	    this.elemento = elemento;
-         }
+            // Aquí va su código.
+        }
 
         /**
          * Nos dice si el vértice tiene un padre.
@@ -40,7 +39,6 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          */
         @Override public boolean hayPadre() {
             // Aquí va su código.
-	    return padre != null;
         }
 
         /**
@@ -50,7 +48,6 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          */
         @Override public boolean hayIzquierdo() {
             // Aquí va su código.
-	    return izquierdo != null;
         }
 
         /**
@@ -60,7 +57,6 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          */
         @Override public boolean hayDerecho() {
             // Aquí va su código.
-	    return derecho != null;
         }
 
         /**
@@ -68,10 +64,8 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return el padre del vértice.
          * @throws NoSuchElementException si el vértice no tiene padre.
          */
-        @Override public VerticeArbolBinario<T> padre() throws NoSuchElementException {
+        @Override public VerticeArbolBinario<T> padre() {
             // Aquí va su código.
-	    if(!hayPadre()) throw new NoSuchElementException();
-	    return padre;
         }
 
         /**
@@ -79,10 +73,8 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return el izquierdo del vértice.
          * @throws NoSuchElementException si el vértice no tiene izquierdo.
          */
-        @Override public VerticeArbolBinario<T> izquierdo() throws NoSuchElementException{
+        @Override public VerticeArbolBinario<T> izquierdo() {
             // Aquí va su código.
-	    if(!hayIzquierdo()) throw new NoSuchElementException();
-	    return izquierdo;
         }
 
         /**
@@ -90,27 +82,16 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return el derecho del vértice.
          * @throws NoSuchElementException si el vértice no tiene derecho.
          */
-        @Override public VerticeArbolBinario<T> derecho() throws NoSuchElementException{
+        @Override public VerticeArbolBinario<T> derecho() {
             // Aquí va su código.
-	    if(!hayDerecho()) throw new NoSuchElementException();
-	    return derecho;
         }
 
-	private int max(int a, int b){
-	    if(a>b)
-		return a;
-	    return b;
-	}
-	private int altura(Vertice v){
-	    if(v==null) return -1;
-	    return 1 + max(altura(v.izquierdo),altura(v.derecho));
-	}
         /**
          * Regresa la altura del vértice.
          * @return la altura del vértice.
          */
         @Override public int altura() {
-            return altura(this);
+            // Aquí va su código.
         }
 
         /**
@@ -118,9 +99,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return la profundidad del vértice.
          */
         @Override public int profundidad() {
-            if(!hayPadre())
-		return 0;
-	    return 1 + padre.profundidad();
+            // Aquí va su código.
         }
 
         /**
@@ -129,7 +108,6 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          */
         @Override public T get() {
             // Aquí va su código.
-	    return elemento;
         }
 
         /**
@@ -146,17 +124,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
             if (objeto == null || getClass() != objeto.getClass())
                 return false;
             @SuppressWarnings("unchecked") Vertice vertice = (Vertice)objeto;
-            if(elemento == vertice.elemento){
-		if(izquierdo != null && derecho != null)
-		    return izquierdo.equals(vertice.izquierdo) && derecho.equals(vertice.derecho);
-		else if(izquierdo != null)
-		    return izquierdo.equals(vertice.izquierdo);
-		else if(derecho != null)
-		    return derecho.equals(vertice.derecho);
-              else 
-		  return true;
-            }
-            return false;
+            // Aquí va su código.
         }
 
         /**
@@ -164,7 +132,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return una representación en cadena del vértice.
          */
         @Override public String toString() {
-            return elemento.toString();
+            // Aquí va su código.
         }
     }
 
@@ -185,8 +153,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *        binario.
      */
     public ArbolBinario(Coleccion<T> coleccion) {
-	for(T t: coleccion)
-	    agrega(t);
+        // Aquí va su código.
     }
 
     /**
@@ -199,7 +166,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return un nuevo vértice con el elemento recibido dentro del mismo.
      */
     protected Vertice nuevoVertice(T elemento) {
-        return new Vertice(elemento);
+        // Aquí va su código.
     }
 
     /**
@@ -208,9 +175,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return la altura del árbol.
      */
     public int altura() {
-	if(raiz==null)
-	    return -1;
-        return raiz.altura();
+        // Aquí va su código.
     }
 
     /**
@@ -218,7 +183,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return el número de elementos en el árbol.
      */
     @Override public int getElementos() {
-	return elementos;
+        // Aquí va su código.
     }
 
     /**
@@ -228,18 +193,9 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *         <code>false</code> en otro caso.
      */
     @Override public boolean contiene(T elemento) {
-        return busca(elemento)!=null;
+        // Aquí va su código.
     }
-    private VerticeArbolBinario<T> busca(T elemento, Vertice vertice){
-      if(vertice == null)
-	  return null;
-      if(vertice.elemento.equals(elemento))
-	  return vertice;
-      VerticeArbolBinario<T> v = busca(elemento, vertice.izquierdo);
-      if(v != null)
-	  return v;
-      return busca(elemento, vertice.derecho);
-     } 
+
     /**
      * Busca el vértice de un elemento en el árbol. Si no lo encuentra regresa
      * <code>null</code>.
@@ -248,7 +204,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *         <code>null</code> en otro caso.
      */
     public VerticeArbolBinario<T> busca(T elemento) {
-        return busca(elemento,raiz);
+        // Aquí va su código.
     }
 
     /**
@@ -257,8 +213,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @throws NoSuchElementException si el árbol es vacío.
      */
     public VerticeArbolBinario<T> raiz() {
-        if(esVacia()) throw new NoSuchElementException();
-	return raiz;
+        // Aquí va su código.
     }
 
     /**
@@ -267,15 +222,14 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *         otro caso.
      */
     @Override public boolean esVacia() {
-        return raiz == null;
+        // Aquí va su código.
     }
 
     /**
      * Limpia el árbol de elementos, dejándolo vacío.
      */
     @Override public void limpia() {
-        raiz=null;
-	elementos=0;
+        // Aquí va su código.
     }
 
     /**
@@ -289,61 +243,15 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
             return false;
         @SuppressWarnings("unchecked")
             ArbolBinario<T> arbol = (ArbolBinario<T>)objeto;
-        if(raiz == null && arbol.raiz == null) 
-          return true;
-        else if(raiz == null || arbol.raiz == null)
-	    return false;
-        if(raiz.equals(arbol.raiz))
-	    return true;
-        return false;
-    }
-    private String dibujaEspacios(int l, int[] arr){
-      String res = "";
-      for(int i = 0; i<l;i++){
-        if(arr[i] == 1) 
-          res += "│  ";
-        else 
-          res += "   ";
-      }
-      return res;
+        // Aquí va su código.
     }
 
-    private String toString(Vertice v, int l, int[] arr){
-	String res = v.toString() + '\n';
-	arr[l] = 1;
-	if(v.izquierdo != null && v.derecho != null){
-	    res += this.dibujaEspacios(l,arr);
-	    res += "├─›";
-	    res += this.toString(v.izquierdo, l+1, arr);
-	    res += this.dibujaEspacios(l,arr);
-	    res += "└─»";
-	    arr[l] = 0;
-	    res += this.toString( v.derecho, l+1, arr);
-	} else if(v.izquierdo != null){
-	    res += this.dibujaEspacios(l,arr);
-	    res += "└─›";
-	    arr[l] = 0;
-	    res += this.toString( v.izquierdo, l+1, arr);
-	} else if(v.derecho != null){
-	    res += this.dibujaEspacios(l,arr);
-	    res += "└─»";
-	    arr[l] = 0;
-	    res += this.toString( v.derecho, l+1, arr);
-	}
-	return res;
-    }
     /**
      * Regresa una representación en cadena del árbol.
      * @return una representación en cadena del árbol.
      */
     @Override public String toString() {
-	if(raiz ==  null)
-	    return "";
-	int a = altura() + 1;
-	int[] arr = new int[a];
-	for(int i = 0; i < a; i++)
-	    arr[i] = 0;
-	return toString(raiz,0,arr);
+        // Aquí va su código.
     }
 
     /**
